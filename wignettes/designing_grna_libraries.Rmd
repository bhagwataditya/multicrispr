---
title: "Crispr/Cas9 gRNA design"
author: "Aditya M Bhagwat"
date: "1 11 2019"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{finding_flank_cas9s}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Overview {-}

Crispr/Cas9, first described in 1987, later understood to be a prokaryotic immune system, has now transformed into a powerful and versatile tool for genome engineering, with continuing active development. As a genome engineering tool, it consists of two parts: the **Cas9** enzyme that unwinds and cuts double stranded DNA, and a **gRNA** (guide RNA) that targets the Cas9 enzyme to a specific genomic locus based on complementarity to a 23-bp N20NGG sequence.

The task of designing a Crispr/Cas9 gRNA library to target a set of genomic loci consists of the following steps:

1. Define genomic targets
2. Extend or flank targets (e.g. extend to ensure 23-bp width, flank to target promotors/enhancers)
3. Find potential N20NGG Cas9 sites within target loci
4. Predict targeting efficiency and filter for expected efficiency.
5. Find offtarget (mis)matches and filter for offtarget-free Cas9
6. Return offtarget-free, expectedly efficient Crispr/Cas9 gRNA site/sequence library


```{r setup, include=FALSE, results='hide'}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE)
```

# Define targets

As a first step, genomic targets are defined as `GRanges` (R/BioC class to represent genomic ranges). 
Convenient functions are provided to make this step easy.  

The functions `genes_to_granges` or `genefile_to_granges` convert geneids into a GRanges, using a TxDb gene models object. Most Cas9 applications are strand-agnostic, so by default complementary strands are included with `complement = TRUE`:


```{r, echo = FALSE, results = FALSE, message=FALSE}
# Not required
# Done to load dependencies silently - keeping focus
require(GenomicRanges)
require(Biostrings)
require(dplyr)
require(dbplyr)
require(htmltools)
require(htmlwidgets)
```

```{r}
# Convert gene ids into GRanges
require(multicrispr)
entrezfile <- system.file('extdata/SRF.entrez', package = 'multicrispr')
txdb <- TxDb.Mmusculus.UCSC.mm10.knownGene::TxDb.Mmusculus.UCSC.mm10.knownGene
targets0 <- genefile_to_granges(entrezfile, txdb, complement = TRUE)
```

Alternatively, the function `bed_to_granges` directly reads a (0-based) BED file into a (1-based) GRanges object:

```{r}
# Read bedfile into GRanges
require(multicrispr)
bedfile <- system.file('extdata/SRF.bed', package = 'multicrispr')
targets0 <- bed_to_granges(bedfile, genome = 'mm10')
```


# Extend/Flank targets

As a second step, extension or flanking may be required. The functions `left_flank`, `right_flank`, and `double_flank` flank target ranges, e.g. in order to target promoters or enhancers rather than TSS:

```{r}
# Left flank
targets <- left_flank(  targets0, leftstart =-200, leftend = -1)

# Right flank
targets <- right_flank( targets0, rightstart=   1, rightend=200)

# Double flank
targets <- double_flank(targets0, leftstart = -200, leftend=-1, rightstart=1, rightend=200)
```


The function `extend` expands target ranges in either (or both) direction(s), ensuring proper width to contain 23 base Cas9 sites.

```{r}
targets <- extend(targets0, leftstart=-22, rightend=22)
```


# Find cas9 sites

The third step consists of finding N~20~NGG Cas9 sites within the target ranges.  
First, we use `add_seq` to extract the relevant sequences using a BSgenome (R/BioC genome sequence object).  
Then we use `find_cas9s` to find N~20~NGG Cas9 sequences and ranges within targets.
The associated plot shows that (nearly) all targets have Cas9 sites.

```{r}
bsgenome <- BSgenome.Mmusculus.UCSC.mm10::BSgenome.Mmusculus.UCSC.mm10
targets <- add_seq(targets, bsgenome)
cas9s <- find_crisprsites(targets)
```

# Predict targeting efficiency

Not all N~20~NGG gRNA sequences target equally well (even when matching sequence perfectly). For each position in the 23-bp gRNA sequence, the  nucleotide present in current, previous and next position has an effect on targeting efficiency. Doench et al. (2014) were the first to systematically investigate the relationship between sequence and targeting efficiency, which they summarized in their 2014 prediction model. The function `score_cas9s` uses this model to compute the Doench 2014 targeting efficiency predictions:

```{r}
cas9s <- score_crisprsites(cas9s, bsgenome, method = 'Doench2014')
cas9s
```

The same authors later developed an updated model (Doench et al., 2016), which to-date remains the most comprehensive prediction model developed and the current community standard. The prediction model was implemented as a python module, which the authors freely share on github (github/MicrosoftResearch/azimuth). The installation of this python module is fairly straightforward:

1. Install conda for python 2.7
2. Create a new conda environment: `conda create --name azimuthenv python=2.7`
3. Activate conda environment:     `conda activate azimuthenv`
4. Install module azimuth:         `pip install azimuth`
5. Install scikit-learn:           `pip install scikit-learn==0.17.1`

Once azimuth is installed, `score_cas9s` can compute the Doench2016 score as well, under the hood calling the python module azimuth with a little help from the amazing R-to-python reticulate package.

```{r}
# Install azimuth
# Important: run R(Studio) with admin privileges for this to work
  install_azimuth <- FALSE
  if (install_azimuth){
    reticulate::conda_create('azienv', 'python=2.7')                         # Create condaenv 'azimuth'
    reticulate::conda_install('azienv', 'azimuth', pip = TRUE)               # Install azimuth
    reticulate::conda_install('azienv', 'scikit-learn==0.17.1', pip = TRUE)  # Install scikit-learn
  }

# Score Doench2016
  if (reticulate::py_module_available('azimuth')){
      cas9s <- score_cas9s(cas9s, bsgenome, method = 'Doench2016', condaenv = 'azienv')
      cas9s
  }

# Filter
cas9s <- cas9s[cas9s$Doench2016 > 0.5]

```


# Prevent offtarget effects

Finally, we can restrict the Cas9 sites further to only those that have no offtarget effects. 
For purposes of demonstration, let us restrict ourselves to Y-chromosome targets.


```{r}
cas9s   %<>% magrittr::extract(GenomicRanges::seqnames(.) == 'chrY')
targets %<>% magrittr::extract(GenomicRanges::seqnames(.) == 'chrY')
offtargetfree_cas9s <- filter_no_offtargets(cas9s, targets, bsgenome, offtargetchr = 'chrY')
offtargetfree_cas9s
```


```{r quasr, eval = FALSE}

  # cas9seqs
  cas9seqs   <- unique(cas9s$seq)
  Biostrings::writeXStringSet(Biostrings::DNAStringSet(cas9seqs), 'cas9s.fa')
  cas9seqdt <- data.table::data.table(cas9 = cas9seqs)

  # targets0
  trgts <- targets
  trgts <- trgts[strand(trgts)=='+']
  trgtseqs <- Biostrings::DNAStringSet(trgts$seq)
  names(trgtseqs) <- sprintf('%s:%s-%s', seqnames(trgts), start(trgts), end(trgts))
  Biostrings::writeXStringSet(trgtseqs, 'targets.fa')
  for (mis in 0:2){
      alignmentpar <- sprintf('-m 10000 -v %d -a', mis)
      res <- QuasR::qAlign('samples.txt', genome = 'targets.fa', alignmentParameter = alignmentpar)
      res <- QuasR::qAlign('samples.txt', genome = 'BSgenome.Mmusculus.UCSC.mm10', alignmentParameter = alignmentpar)
      ba <- Rsamtools::scanBam(res@alignments$FileName)[[1]]
      dt <- data.table::data.table(cas9 = as.character(ba$seq))
      varname <- sprintf('targets%d', mis)
      dt[, (varname) := .N, by = 'cas9']
      dt <- unique(dt)
      cas9seqdt %<>% merge(dt, by = 'cas9', sort = FALSE)
  }
```





